-- What about the partial search (aka wild card)
-- we use LIKE and % (WILD CARD)
-- % can represent 0 or more character of any kind
-- _ can represent exactly one character of any kind

-- Wild card only works on VARCHAR (i.e. String)

/*
 'D%' -- anything that starts with D
 ex: David, Danny, Dog
 '%d' -- anything that ends with d
 ex: Sid, Bid, Kid, Dad
 '%d%' -- anything that contains d
 Aladdin, Cassandra, Adam, Brandon , Daddy
 Sid, Bid, Kid, Dad
 david, dog , danny, dime

 'D%a' -- anything that starts with D and end with a
          Diana, Donna, Damla, Daria

 'S%e%n'-- anything starts S with end with n and have e somewhere in the middle
 ex: Steven, Stephan , Selen, Serkan, Sebastian

 'T_' -- anything starts with T and followed by  exactly one character of any kind
 ex: Tj, DT, Ta, T!, TV , T2

 '_a_' -- starts with any one character, followed by a  and followed by any one character
 Dad, Man, Fat, Tab, Gap, Mad

 */

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE 'D%';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE '%d';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE '%d%';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE 'D%a';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE 'S%e%n';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE 'T_';

SELECT FIRST_NAME
From EMPLOYEES
WHERE FIRST_NAME LIKE '_a_';

-- Any phone number that starts with 515
SELECT PHONE_NUMBER
FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '515%';

-- all the phone number that contains 121
SELECT PHONE_NUMBER
FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '%.121.%';

-- YOU CAN OPTIONALLY GIVE AN ALIAS(NICKNAME) FOR YOUR COLUMN
-- TO CHANGE THE RESULTING COLUMN NAME (ONLY CHANGING DISPLAY BUT NOT ACTUALLY IN THE DA)
-- USING THE KEYWORD AS RIGHT AFTER COLUMN NAME
-- and  PROVIDE NICKNAME Either without " " if single word
-- and USE "" IF MORE THAN ONE WORD  AS "MORE THAN ONE"


-- Display all First_Name, SALARY in EMPLOYEES table
-- Modify the column name for Salary in result to Money

SELECT FIRST_NAME, SALARY AS MONEY
FROM EMPLOYEES;

-- Display all FIRST_NAME, LAST_NAME  in EMPLOYEES table
-- Modify the column name for AS BELOW
-- FIRST_NAME -> GIVEN_NAME and  LAST_NAME -> FAMILY_NAME

--SELECT  FIRST_NAME AS GIVEN NAME , LAST_NAME AS FAMILY NAME
--FROM EMPLOYEES

-- P.S IF GIVEN NAME WAS WRITTEN LIKE GIVEN_NAME. "" WON'T BE NEEDED BECAUSE IT IS CONSIDERED AS A SINGLE WORD

SELECT FIRST_NAME AS "GIVEN NAME", LAST_NAME AS "FAMILY NAME"
FROM EMPLOYEES;

-- CONCATENATION IN SQL USE DOUBLE PIPE ||  (THIS IS NOT OR)
-- DISPLAY FULL NAME OF EMPLOYEE

-- WE CAN CONCATENATE AS MANY STUFF AS WE WANT
-- SPACE IS ' ' EMPTY STRING

SELECT FIRST_NAME,
       LAST_NAME,
       FIRST_NAME || ' ' || LAST_NAME AS "FULL NAME" -- CONCATENATE AND GIVE IT A NICKNAME(FULL NAME)
FROM EMPLOYEES;

--- ARITHMETIC OPERATIONS:  + - * /
-- Display EMPLOYEE NAME AND SALARY AND INCREASED_SALARY AFTER 5000$ RAISE

SELECT FIRST_NAME,
       SALARY,
       SALARY + 5000 AS "INCREASED-SALARY"
FROM EMPLOYEES;

-- Display EMPLOYEE NAME AND SALARY
-- AND DECREASED_SALARY AFTER 2000$ CUT

SELECT FIRST_NAME,
       SALARY,
       SALARY - 2000 AS "SALARY CUT"
FROM EMPLOYEES;

-- Display EMPLOYEE NAME AND SALARY
-- AND YEARLY SALARY -- MULTIPLY BY 12

SELECT FIRST_NAME,
       SALARY,
       SALARY * 12 AS "YEARLY SALARY"
FROM EMPLOYEES;


-- Display EMPLOYEE NAME AND SALARY
-- AND WEEKLY SALARY -- DIVIDE BY

SELECT FIRST_NAME,
       SALARY,
       SALARY / 4 AS "WEEKLY SALARY"
FROM EMPLOYEES;

/*
 WE CAN WRITE ALL THIS IN ONE SELECT STATEMENT SINCE WE ARE DEALING WITH ONE TABLE
 THIS WILL GIVE THE RESULT IN ONE TABLE

 */
 SELECT FIRST_NAME, SALARY,
 SALARY + 500 AS "INCREASED_SALARY",
 SALARY - 2000 AS "DECREASED_SALARY",
 SALARY *12 AS "YEARLY_SALARY",
 SALARY/4 AS "WEEKLY_SALARY"
 FROM EMPLOYEES;

--- SQL BUILT-IN FUNCTIONS:
--- REUSABLE CODE THAT WRAPPED INTO FUNCTION FOR COMMON TASKS
--- LIKE ROUNDING NUMBERS, GETTING LENGTH OF STR AND MORE
--- SINGLE ROW FUNCTION:
-- IT AFFECTS EACH AND EVERY ROW AND RETURN SAME NUMBER OF ROW

-- FEW TEXT FUNCTIONS :
-- UPPER : ACCEPTS ONE PARAMETER (COLUMN NAME) AND RETURN UPPERCASE
-- LOWER : ACCEPTS ONE PARAMETER (COLUMN NAME) AND RETURN LOWERCASE
-- LENGTH: RETURNS THE LENGTH OF STRING

-- Display FIRST_NAME, and UPPERCASE FIRST NAME IN EMPLOYEE TABLE
SELECT FIRST_NAME, UPPER(FIRST_NAME)
FROM EMPLOYEES;


-- Display FIRST_NAME, and LOWERCASE FIRST NAME IN EMPLOYEE TABLE
SELECT FIRST_NAME, LOWER(FIRST_NAME)
FROM EMPLOYEES;

-- Display FIRST_NAME, and LENGTH OF FIRST NAME IN EMPLOYEE TABLE
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES;

-- PUT THEM ALL TOGETHER IN ONE TABLE
SELECT FIRST_NAME,
       UPPER(FIRST_NAME) AS "UPPERCASE_NAME",
       LOWER(FIRST_NAME) AS "LOWERCASE_NAME",
       LENGTH(FIRST_NAME) AS "CHAR_COUNT"
FROM EMPLOYEES;

-- FIND OUT ALL FIRST_NAME AND CHARACTER COUNT
-- ONLY DISPLAY IF CHARACTER COUNT IS EXACTLY 5

SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME)=5;

--- ONLY DISPLAY IF FIRST NAME CHARACTER COUNT IS MORE THAN 10
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME)>10;

--- ONLY DISPLAY IF FIRST NAME CHARACTER COUNT IS BETWEEN 7-9
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME) BETWEEN 7 AND 9;

--- ONLY DISPLAY IF FIRST NAME CHARACTER COUNT IS NOT BETWEEN 5-10
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME) NOT BETWEEN  5 AND 10;

--- ONLY DISPLAY IF FIRST NAME CHARACTER COUNT IS 2 0R 9 OR 11
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES
WHERE LENGTH(FIRST_NAME) IN (2,9,11);

-- FIND OUT ALL FIRST_NAME THAT CONTAINS d or D
-- SOLUTION 1
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%D%'
OR FIRST_NAME LIKE '%d%';

-- SOLUTION 2
SELECT FIRST_NAME, UPPER(FIRST_NAME)
FROM EMPLOYEES
-- WHERE FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%d%'
WHERE UPPER(FIRST_NAME) LIKE '%D%';

-- YOU CAN USE SINGLE ROW FUNCTION ANYWHERE
-- Including in select column list, condition, order by..etc

SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY LENGTH(FIRST_NAME)  ; -- THE DEFAULT ORDER IS THE ASCENDING ORDER (NO NEED TO BE WRITTEN)

SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY LENGTH(FIRST_NAME) DESC  ;


-- NUMBER FUNCTIONS:
-- ROUND ( DECIMAL NUMBER HERE) --> ROUNDED NUMBER
-- ROUND (DECIMAL NUMBER HERE, DIGIT YOU WANNA KEEP)
--               --> ROUNDED NUMBER WITH DESIRED DIGIT
-- ROUND (3.4444444, 1) => 3.4
-- ROUND (3.4444444, 2) => 3.44
-- ROUND (3.4444444, 3) => 3.444
-- ROUND (3.4444444, 4) => 3.4444

-- FIND OUT SALARY AND DAILY SALARY OF EMPLOYEE

SELECT SALARY ,
       ROUND (SALARY/30) AS " ROUNDED DAILY SALARY",
       ROUND(SALARY/30, 3)
FROM EMPLOYEES;

-- MULTIROW FUNCTION  | GROUP FUNCTIONS | AGGREGATE FUNCTIONS
-- COUNT, MAX, MIN, SUM , AVG

-- You can use the COUNT function either with * or column name
-- When used with * it will just return the row count (it doesn't care about null values)
-- When used with column name, it will return non-null row count only.

SELECT COUNT(*), COUNT (FIRST_NAME)
FROM EMPLOYEES;

-- We have only 35 employees with commission-pct value not null
-- So the result will be 35
SELECT COUNT(COMMISSION_PCT)
FROM EMPLOYEES;

--GET THE EMPLOYEE COUNT FOR EMPLOYEES WITH DEPARTMENT ID 90

SELECT COUNT(*)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 90;

--MAX
----- FIND OUT HTE MAX SALARY IN EMPLOYEES TABLE

SELECT MAX(SALARY)
FROM EMPLOYEES;

----- FIND OUT HTE MAX SALARY IN EMPLOYEES TABLE
   -- EXCLUDE THE SALARY 24000

SELECT MAX(SALARY)
FROM EMPLOYEES
WHERE SALARY <>24000;

--MIN
--- FIND OUT MINIMUM SALARY IN EMPLOYEES TABLE

SELECT MIN(SALARY)
FROM EMPLOYEES;

--- FIND OUT MINIMUM SALARY IN EMPLOYEES TABLE
-- EXCLUDE THE SALARY 2100

SELECT MIN(SALARY)
FROM EMPLOYEES
WHERE SALARY <> 2100;

--- SUM
-- GET THE SUM OF ENTIRE EMPLOYEE SALARY

SELECT SUM(SALARY)
FROM EMPLOYEES;

-- GET THE SUM OF ENTIRE EMPLOYEE SALARY FOR DEPARTMENT_ID 90

SELECT SUM (SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID=90;

-- AVG
-- FIND OUT AVERAGE SALARY FOR ALL EMPLOYEES
SELECT AVG (SALARY), ROUND ( AVG (SALARY) )
FROM EMPLOYEES;

--- ALL IN ONE SHOT
SELECT COUNT(*) AS "EMPLOYEE COUNT",
       MAX(SALARY) AS "HIGHEST SALARY",
       MIN(SALARY) AS "LOWEST SALARY",
       SUM(SALARY) AS "SUM OF ALL SALARY",
       AVG (SALARY) AS "AVERAGE SALARY "
FROM EMPLOYEES;

------ GROUP BY , CAN BE USED ALONG WITH MULTI-ROW (AGGREGATE, GROUP)FUNCTIONS
-- -- TO GENERATE RESULT PER GROUP INSTEAD OF ALL TABLE
-- -- IT CAN ONLY BE USED ALONG WITH MULTI-ROW (AGGREGATE, GROUP)FUNCTIONS

-- DISPLAY COUNT OF EMPLOYEES IN EACH DEPARTMENT
SELECT DEPARTMENT_ID,
       COUNT(*) AS "DEP_EMP_COUNT"
FROM EMPLOYEES
GROUP BY (DEPARTMENT_ID);
-- THE ONLY TIME WE CAN ADD ADDITIONAL COLUMN ALONG SIDE A GROUP FUNCTION IS IF YOU GROUP BY THE SAME COLUMN

--DISPLAY COUNT OF EMPLOYEES IN EACH JOB_ID
-- P.S EVERYTIME  WE SEE THE WORD EACH IMMEDIATELY THINK ABOUT GROUP BY!!
SELECT JOB_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID;


--DISPLAY COUNT OF EMPLOYEES IN EACH MANAGER_ID
SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY MANAGER_ID;

--- DISPLAY THE MAX SALARY FOR EACH DEPARTMENT
--- DISPLAY THE AVG SALARY FOR EACH DEPARTMENT
--- DISPLAY THE SUM SALARY FOR EACH DEPARTMENT
SELECT DEPARTMENT_ID, MAX(SALARY) AS "HIGHEST SALARY",
       MIN(SALARY) AS "LOWEST SALARY",
       ROUND ( AVG(SALARY) ,3 ) AS "AVERAGE SALARY",
       SUM(SALARY) AS "TOTAL SALARY"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--- DISPLAY THE MIN , MAX, SUM AND AVERAGE SALARY FOR EACH JOB_ID
SELECT JOB_ID, MAX(SALARY) AS "HIGHEST SALARY",
       MIN(SALARY) AS "LOWEST SALARY",
       ROUND ( AVG(SALARY) ,3 ) AS "AVERAGE SALARY",
       SUM(SALARY) AS "TOTAL SALARY"
FROM EMPLOYEES
GROUP BY JOB_ID;

-- USING COUNTRY
-- DISPLAY COUNT OF COUNTRIES IN EACH REGION
-- WE CAN USE COUNTRY_ID INSTEAD OF * IT DOESN'T MATTER , IT ONLY MATTERS IF WE HAVE A NULL VALUE
SELECT REGION_ID, COUNT (COUNTRY_ID) AS "COUNT OF COUNTRIES"
FROM COUNTRIES
GROUP BY REGION_ID;

-- HAVING
-- CAN BE USED AFTER GROUP BY TO FILTER
-- ALREADY COMBINED RESULT FURTHERMORE
-- YOU CAN ONLY USE HAVING IF YOU ARE USING AGGREGATE FUNCTION IN CONDITION AFTER GROUP BY
-- FOR EXAMPLE IF COUNT OF EMPLOYEES IN EACH DEPARTMENT IS MORE THAN 10
--- HAVING COUNT (*) >10 , WHERE COUNT (*) WILL NEVER WORK

--DISPLAY COUNT OF EMPLOYEES IN EACH DEPARTMENT
-- ONLY DISPLAY IF THE COUNT OF EMPLOYEES ARE MORE THAN 10
SELECT DEPARTMENT_ID,
       COUNT(*) AS "DEP_EMP_COUNT"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*)>10;

-- DISPLAY THE MAX SALARY IN EACH DEPARTMENT
-- ONLY DISPLAY IF THE DEPARTMENT MAX SALARY IS MORE THAN 10000
SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
-- WHERE MAX (SALARY) > 10000 | DO NOT DO THIS !! WHERE DOES NOT WORK WITH AGGREGATED RESULT
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY)>10000;

-- DISPLAY THE MAX SALARY IN EACH DEPARTMENT
-- ONLY DISPLAY THOSE IF DEPARTMENT_ID IS NOT 100
SELECT DEPARTMENT_ID , MAX(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID != 100
GROUP BY DEPARTMENT_ID
HAVING DEPARTMENT_ID !=100 ;

-- ANY TIME WE USE FUNCTION WE CANNOT USE THE WHERE CLUE !! VERY IMPORTANT (THIS IS THE DIFFERENCE BETWEEN HAVING AND WHERE)


